# Audio capture

```elixir
File.cd(__DIR__)
Logger.configure(level: :error)

Mix.install([
  {:membrane_core, "~> 0.11.2"},
  {:membrane_file_plugin, "~> 0.13.0"},
  {:membrane_kino_plugin, path: ".."},
  {:membrane_opus_plugin, "~> 0.16.0"},
  {:membrane_aac_fdk_plugin, "~> 0.14.0"},
  {:membrane_aac_plugin, "~> 0.13.0"},
  {:membrane_wav_plugin, "~> 0.8.0"},
  {:membrane_generator_plugin, "~> 0.8.0"},
  {:membrane_raw_audio_format, "~> 0.10.0"},
  {:membrane_matroska_plugin, "~> 0.2.1"}
])
```

## Section

```elixir
alias Membrane.RemoteControlled, as: RC
import Membrane.ChildrenSpec, only: [{:child, 2}, {:child, 3}, {:via_in, 2}]

alias Membrane.{
  Opus,
  File,
  AAC,
  WAV,
  Matroska
}
```

```elixir
defmodule Membrane.Custom.Filter do
  use Membrane.Filter

  alias Membrane.Buffer

  def_options(
    fun: [
      spec: (buffer :: %Buffer{} -> buffer :: %Buffer{}),
      default: &Function.identity/1
    ],
    stream_format: [
      spec: (stream_format :: any() -> stream_format :: any()),
      default: &Function.identity/1
    ]
  )

  def_input_pad(:input,
    accepted_format: _any,
    demand_mode: :auto
  )

  def_output_pad(:output,
    accepted_format: _any,
    demand_mode: :auto
  )

  @impl true
  def handle_init(_ctx, options) do
    {[], options}
  end

  @impl true
  def handle_stream_format(_pad, stream_format, _ctx, state) do
    stream_format = state.stream_format.(stream_format)
    {[stream_format: {:output, stream_format}], state}
  end

  @impl true
  def handle_process(_pad, buffer, _context, state) do
    buffer = state.fun.(buffer)
    {[buffer: {:output, buffer}], state}
  end
end

:ok
```

```elixir
kino_input = Membrane.Kino.Input.new()
kino_player = Membrane.Kino.Player.new(:audio)
:ok
```

```elixir
aac_to_file =
  child(:input, %Membrane.Kino.InputSourceBin{kino: kino_input})
  |> child(:from_opus, Opus.Decoder)
  |> child(:to_aac, AAC.FDK.Encoder)
  |> child(:file, %File.Sink{location: "./tmp/test.aac"})

play_audio =
  child(:input, %Membrane.Kino.InputSourceBin{kino: kino_input})
  |> child(:from_opus, Opus.Decoder)
  |> child(:to_aac, AAC.FDK.Encoder)
  |> via_in(:audio)
  |> child(:player, %Membrane.Kino.Player.Sink{kino: kino_player})

play_aac =
  child(:input, %File.Source{location: "./tmp/test.aac"})
  |> child(:parser, AAC.Parser)
  |> via_in(:audio)
  |> child(:player, %Membrane.Kino.Player.Sink{kino: kino_player})

:ok
```

```elixir
kino_input |> Kino.render()
kino_player
```

```elixir
structure = play_audio
pipeline = RC.Pipeline.start!()
RC.Pipeline.exec_actions(pipeline, spec: structure, playback: :playing)
```

```elixir
Kino.Input.audio("")
```
