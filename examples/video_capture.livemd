# Video capture and loopback

```elixir
File.cd(__DIR__)
Logger.configure(level: :error)

Mix.install([
  {:membrane_core, "~> 1.0"},
  {:membrane_kino_plugin, path: ".."},
  # livebook doesn't cooperate
  {:membrane_raw_video_format, "~> 0.3.0"},
  {:membrane_ffmpeg_swscale_plugin, "~> 0.15.1"},
  {:membrane_funnel_plugin, "~> 0.9.0"},
  {:membrane_h264_ffmpeg_plugin, "~> 0.31.6"},
  {:membrane_fake_plugin, "~> 0.11.0"},
  {:membrane_matroska_plugin, "~> 0.5.1"},
  {:membrane_h264_rgb_plugin, path: "../../membrane_h264_rgb_plugin"}
])
```

## Pipeline definition

Live input video is requested from web browser (webcam), fed into elixir pipeline and back into kino player.

```elixir
import Membrane.ChildrenSpec

alias Membrane.Time
alias Membrane.RCPipeline, as: RC

width = 100
height = 100

kino_input =
  Membrane.Kino.Input.new(
    audio: true,
    video: true,
    flush_time: Time.milliseconds(10)
  )

kino_player =
  Membrane.Kino.Player.new(
    audio: false,
    video: true,
    mirror: true,
    flush_time: Time.milliseconds(10)
  )

# rgb bin example
# |> child(:rgb_decoder, %Membrane.H264_RGB.Decoder{
# resolution: %{width: width, height: height}
# resolution: :native
# })
# |> child(:rgb_encoder, Membrane.H264_RGB.Encoder)

video_loopback = [
  child(:source, %Membrane.Kino.Input.SourceBin{kino: kino_input})
  |> via_out(:video)
  |> via_in(:video)
  |> child(:player, %Membrane.Kino.Player.Sink{kino: kino_player}),
  get_child(:source)
  |> via_out(:audio)
  |> child(:fake_audio_sink, Membrane.Fake.Sink.Buffers)
]

:ok
```

## Playing pipeline

```elixir
pipeline = RC.start!()
RC.exec_actions(pipeline, spec: video_loopback)

Kino.render(kino_input)
kino_player
```
